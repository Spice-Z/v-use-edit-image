{"code":"import { __awaiter, __generator } from \"tslib\";\r\nimport { ref } from 'vue-demi';\r\nvar write = function (context, props, canvasHeight) {\r\n    context.font = \"bold \" + props.fSize + \"px \\\"\\u30D2\\u30E9\\u30AE\\u30CE\\u89D2\\u30B4 ProN W3\\\", \\\"Hiragino Kaku Gothic ProN\\\", \\\"\\u30E1\\u30A4\\u30EA\\u30AA\\\", \\\"Meiryo\\\", \\\"verdana\\\", sans-serif\";\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = props.isTextAlignCenter ? 'center' : 'start';\r\n    context.strokeStyle = props.strokeStyle;\r\n    context.lineWidth = props.lineWidth;\r\n    var posY = props.y === 'bottom' ? canvasHeight - props.fSize : props.y;\r\n    if (props.shouldShowShadow) {\r\n        context.shadowColor = '#000';\r\n        context.shadowBlur = 6;\r\n        context.shadowOffsetX = 0;\r\n        context.shadowOffsetY = 0;\r\n    }\r\n    else {\r\n        context.shadowColor = 'none';\r\n        context.shadowBlur = 0;\r\n        context.shadowOffsetX = 0;\r\n        context.shadowOffsetY = 0;\r\n    }\r\n    var lineHeight = props.fSize * 1.1618;\r\n    props.text.split('\\n').forEach(function (t, i, a) {\r\n        var y = posY - lineHeight * (a.length - (i + 1));\r\n        if (props.backgroundColor) {\r\n            context.fillStyle = props.backgroundColor;\r\n            var bgW = context.measureText(t).width * 1.1;\r\n            context.fillRect(props.x - bgW / 2, y - lineHeight / 2, bgW, lineHeight);\r\n        }\r\n        context.fillStyle = props.color;\r\n        context.fillText(t, props.x, y);\r\n        if (props.hasStroke) {\r\n            context.strokeText(t, props.x, y);\r\n        }\r\n    });\r\n};\r\nvar drawShapeToCanvas = function (context, props) {\r\n    context.lineWidth = props.lineWidth;\r\n    context.beginPath();\r\n    props.coordinates.forEach(function (v, i) {\r\n        if (i === 0) {\r\n            context.moveTo(v.x, v.y);\r\n            return;\r\n        }\r\n        context.lineTo(v.x, v.y);\r\n    });\r\n    context.closePath();\r\n    if (props.shouldStroke) {\r\n        context.strokeStyle = props.color;\r\n        context.stroke();\r\n    }\r\n    else {\r\n        context.fillStyle = props.color;\r\n        context.fill();\r\n    }\r\n};\r\nvar setRect = function (canvas, x, y) {\r\n    canvas.width = x;\r\n    canvas.height = y;\r\n};\r\nvar clip = function (context, prop) {\r\n    console.log({ prop: prop });\r\n    // const region = new Path2D()\r\n    // region.rect(prop.x, prop.y, prop.width, prop.height)\r\n    // context.clip(region)\r\n    context.drawImage(prop.imageRef.value, prop.x, prop.y, prop.width, prop.height, 0, 0, prop.width, prop.height);\r\n};\r\nexport var useCanvas = function () {\r\n    var canvasRef = ref(null);\r\n    var setCanvasRect = function (x, y) {\r\n        if (canvasRef.value === null) {\r\n            return;\r\n        }\r\n        setRect(canvasRef.value, x, y);\r\n    };\r\n    var drawOriginImage = function (imageRef) { return __awaiter(void 0, void 0, void 0, function () {\r\n        var canvas, ctx;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (canvasRef.value === null || imageRef.value === null) {\r\n                        return [2 /*return*/];\r\n                    }\r\n                    canvas = canvasRef.value;\r\n                    setCanvasRect(imageRef.value.naturalWidth, imageRef.value.naturalHeight);\r\n                    ctx = canvas.getContext('2d');\r\n                    if (ctx === null) {\r\n                        return [2 /*return*/];\r\n                    }\r\n                    return [4 /*yield*/, ctx.drawImage(imageRef.value, 0, 0)];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    }); };\r\n    var drawDecorationImage = function (decorationImageRef, sizePer, dxPer, dyPer) {\r\n        if (sizePer === void 0) { sizePer = 100; }\r\n        if (dxPer === void 0) { dxPer = 'auto'; }\r\n        if (dyPer === void 0) { dyPer = 'auto'; }\r\n        return __awaiter(void 0, void 0, void 0, function () {\r\n            var ctx, sx, sy, sWidth, sHeight, dWidth, dHeight, dx, dy;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (canvasRef.value === null || decorationImageRef.value === null) {\r\n                            return [2 /*return*/, {\r\n                                    dWidth: 0,\r\n                                    dHeight: 0,\r\n                                    dx: 0,\r\n                                    dy: 0,\r\n                                }];\r\n                        }\r\n                        ctx = canvasRef.value.getContext('2d');\r\n                        if (ctx === null) {\r\n                            return [2 /*return*/, {\r\n                                    dWidth: 0,\r\n                                    dHeight: 0,\r\n                                    dx: 0,\r\n                                    dy: 0,\r\n                                }];\r\n                        }\r\n                        sx = 0;\r\n                        sy = 0;\r\n                        sWidth = decorationImageRef.value.naturalWidth;\r\n                        sHeight = decorationImageRef.value.naturalHeight;\r\n                        dWidth = (canvasRef.value.width / 100) * sizePer;\r\n                        dHeight = ((decorationImageRef.value.naturalHeight *\r\n                            (canvasRef.value.width / decorationImageRef.value.naturalWidth)) /\r\n                            100) *\r\n                            sizePer;\r\n                        dx = dxPer === 'auto'\r\n                            ? (canvasRef.value.width / 100) * ((100 - sizePer) / 2)\r\n                            : dxPer === 'right'\r\n                                ? canvasRef.value.width - dWidth\r\n                                : (canvasRef.value.width / 100) * dxPer;\r\n                        dy = dyPer === 'auto'\r\n                            ? canvasRef.value.height - dHeight - canvasRef.value.height * 0.05\r\n                            : dyPer === 'right'\r\n                                ? canvasRef.value.height - dHeight\r\n                                : (canvasRef.value.width / 100) * dyPer;\r\n                        return [4 /*yield*/, ctx.drawImage(decorationImageRef.value, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, {\r\n                                dWidth: dWidth,\r\n                                dHeight: dHeight,\r\n                                dx: dx,\r\n                                dy: dy,\r\n                            }];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    var writeText = function (_a) {\r\n        var _b = _a.fSize, fSize = _b === void 0 ? 62 : _b, _c = _a.x, x = _c === void 0 ? 100 : _c, _d = _a.y, y = _d === void 0 ? 100 : _d, _e = _a.text, text = _e === void 0 ? '' : _e, _f = _a.strokeStyle, strokeStyle = _f === void 0 ? '#000' : _f, _g = _a.lineWidth, lineWidth = _g === void 0 ? 0 : _g, _h = _a.isTextAlignCenter, isTextAlignCenter = _h === void 0 ? false : _h, _j = _a.color, color = _j === void 0 ? '#000' : _j, _k = _a.shouldShowShadow, shouldShowShadow = _k === void 0 ? false : _k, _l = _a.hasStroke, hasStroke = _l === void 0 ? false : _l, _m = _a.backgroundColor, backgroundColor = _m === void 0 ? 'transparent' : _m;\r\n        if (canvasRef.value === null) {\r\n            return;\r\n        }\r\n        var canvas = canvasRef.value;\r\n        var ctx = canvas.getContext('2d');\r\n        if (ctx === null) {\r\n            return;\r\n        }\r\n        var props = {\r\n            fSize: fSize,\r\n            x: x,\r\n            y: y,\r\n            text: text,\r\n            strokeStyle: strokeStyle,\r\n            lineWidth: lineWidth,\r\n            isTextAlignCenter: isTextAlignCenter,\r\n            color: color,\r\n            shouldShowShadow: shouldShowShadow,\r\n            hasStroke: hasStroke,\r\n            backgroundColor: backgroundColor,\r\n        };\r\n        write(ctx, props, canvas.height);\r\n    };\r\n    var drawShape = function (_a) {\r\n        var coordinates = _a.coordinates, color = _a.color, _b = _a.shouldStroke, shouldStroke = _b === void 0 ? false : _b, _c = _a.lineWidth, lineWidth = _c === void 0 ? 4 : _c;\r\n        if (canvasRef.value === null) {\r\n            return;\r\n        }\r\n        var canvas = canvasRef.value;\r\n        var ctx = canvas.getContext('2d');\r\n        if (ctx === null) {\r\n            return;\r\n        }\r\n        var props = {\r\n            coordinates: coordinates,\r\n            color: color,\r\n            shouldStroke: shouldStroke,\r\n            lineWidth: lineWidth,\r\n        };\r\n        drawShapeToCanvas(ctx, props);\r\n    };\r\n    var makeImageGraySepia = function () {\r\n        if (canvasRef.value === null) {\r\n            return;\r\n        }\r\n        var cWidth = canvasRef.value.width;\r\n        var cHeight = canvasRef.value.height;\r\n        var ctx = canvasRef.value.getContext('2d');\r\n        if (ctx === null) {\r\n            return;\r\n        }\r\n        var image = ctx.getImageData(0, 0, cWidth, cHeight);\r\n        var dst = ctx.createImageData(cWidth, cHeight);\r\n        for (var i = 0; i < cHeight; i++) {\r\n            for (var j = 0; j < cWidth; j++) {\r\n                var pix = (i * cWidth + j) * 4;\r\n                /* Gray */\r\n                var gray = 0.299 * image.data[pix] +\r\n                    0.587 * image.data[pix + 1] +\r\n                    0.114 * image.data[pix + 2];\r\n                for (var k = 0; k < 3; k++) {\r\n                    dst.data[pix + k] = image.data[pix + k] = gray;\r\n                }\r\n                /* Sepia */\r\n                dst.data[pix] = (dst.data[pix] / 255) * 240;\r\n                dst.data[pix + 1] = (dst.data[pix + 1] / 255) * 200;\r\n                dst.data[pix + 2] = (dst.data[pix + 2] / 255) * 148;\r\n                dst.data[pix + 3] = image.data[pix + 3];\r\n            }\r\n        }\r\n        ctx.putImageData(dst, 0, 0);\r\n    };\r\n    var clipRect = function (prop) {\r\n        if (canvasRef.value === null) {\r\n            return;\r\n        }\r\n        var ctx = canvasRef.value.getContext('2d');\r\n        if (ctx === null) {\r\n            return;\r\n        }\r\n        ctx.clearRect(0, 0, canvasRef.value.width, canvasRef.value.height);\r\n        setRect(canvasRef.value, prop.width, prop.height);\r\n        clip(ctx, prop);\r\n    };\r\n    return {\r\n        canvasRef: canvasRef,\r\n        setCanvasRect: setCanvasRect,\r\n        drawOriginImage: drawOriginImage,\r\n        drawDecorationImage: drawDecorationImage,\r\n        clipRect: clipRect,\r\n        drawShape: drawShape,\r\n        writeText: writeText,\r\n        makeImageGraySepia: makeImageGraySepia,\r\n    };\r\n};\r\n","references":["/Users/yugo/devOSS/v-use-edit-image/node_modules/vue-demi/lib/index.d.ts"]}
